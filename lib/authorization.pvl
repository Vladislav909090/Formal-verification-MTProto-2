(*
 * MTProto 2.0: Создание авторизационного ключа
 *
 * Модель протокола создания долгосрочного общего ключа между клиентом и сервером Telegram.
 * См. https://core.telegram.org/mtproto/auth_key
 *)

(******************************************************************************)
(* Абстрактные криптографические примитивы                                   *)
(* Определяются отдельно, чтобы не привязывать реализацию шифрования к этому файлу. *)
(******************************************************************************)

(* fpk(PubKey): HashValue — отпечаток публичного ключа *)
(* keyID(SharedKey): HashValue — идентификатор ключа *)
(* encodeRequestDHParams: шифрование запроса DH-параметров (RSA) *)
(* decodeRequestDHParams: расшифровка запроса DH-параметров (RSA) *)
(* encodeAuthorizationMsg / decodeAuthorizationMsg: AES-шифрование с IV *)
(* hashNk: хеш по nk и ключу авторизации *)


(******************************************************************************)
(* Разложение на простые множители — для доказательства работы, не используется *)
(******************************************************************************)

type Prime.
fun mult(Prime, Prime): bitstring.
reduc forall x: Prime, y: Prime;
  factorise(mult(x,y)) = (x,y).


(******************************************************************************)
(* Обмен сообщениями в протоколе авторизации                                 *)
(******************************************************************************)

(* Раунд 1 *)
fun NC(Nonce): Message [data].                     (* Клиент → Сервер *)
fun NS(Nonce, Nonce, HashValue): Message [data].   (* Сервер → Клиент *)

(* Раунд 2 *)
fun REQDH(Nonce, Nonce, Ciphertext): Message [data]. (* Клиент → Сервер *)
fun DH(Nonce, Nonce, Ciphertext): Message [data].    (* Сервер → Клиент *)

(* Раунд 3 *)
fun ENDH(Nonce, Nonce, Ciphertext): Message [data]. (* Клиент → Сервер *)
fun ACK(Nonce, Nonce, HashValue): Message [data].   (* Сервер → Клиент *)

(* Зашифрованные данные внутри сообщений *)
fun D1(Nonce, Nonce, Nonce): Plaintext [data].           (* запрос DH *)
fun AN(Nonce, Nonce, Modulus, G, G): Plaintext [data].   (* ответ с DH *)
fun D2(Nonce, Nonce, G): Plaintext [data].               (* завершение DH *)


(******************************************************************************)
(* Состояние (таблицы)                                                       *)
(******************************************************************************)

table AuthProtClientEphemeralSecrets(Nonce, Z).                      (* секреты клиента *)
table AuthProtClientSessionState(Nonce, Nonce, Nonce, Modulus, G, G, Z).
table AuthProtServerEphemeralSecrets(Z).                             (* секрет сервера *)
table AuthProtServerSessionState(Nonce, Nonce, Nonce, Modulus, G, G, Z).
table DiffieHellmanParametersTable(Modulus, G).                      (* DH-параметры *)


(******************************************************************************)
(* События                                                                   *)
(******************************************************************************)

(* Клиент начинает сессию авторизации *)
event ClientStartsSession(Nonce).
event ClientGetsServerPublicKey(Nonce, PubKey).
event ClientRequestsDHParameters(Nonce, Nonce, Nonce).
event ClientReceivesDHParameters(Nonce, Nonce, Nonce, Modulus, G, G).
event ClientChecksDHParameters(Nonce, Nonce, Nonce, Modulus, G, G, bool).
event ClientAcceptsDHParameters(Nonce, Nonce, Nonce, Modulus, G, G).
event ClientEndsDHExchange(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).
event ClientAcceptsAuthKey(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).
event ClientReceivesAck(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).

(* Серверные события *)
event ServerReceivesRequest(Nonce).
event ServerGeneratesNonce(ProcessID, Nonce).
event ServerAcceptsClient(Nonce, Nonce, Nonce).
event ServerSendsDHParameters(Nonce, Nonce, Nonce, Modulus, G, Z).
event ServerEndsDHExchange(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).
event ServerAcceptsAuthKey(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).
event ServerSendsAck(Nonce, Nonce, Nonce, Modulus, G, G, Z, AuthKey).

(* Компрометация *)
event RevealedRSAKey(PrivKey).
event RevealedAuthKey(AuthKey).
event RevealedServerAuthKey(AuthKey).
event RevealedNk(Nonce).
event RevealedAuthProtClientExponent(Z).
event RevealedAuthProtClientEphemeralSecrets(Nonce, Z).
event RevealedAuthProtServerExponent(Z).

(* Компрометация после завершения протокола *)
event PostCompromisedRSAKey(PrivKey).
event PostCompromisedAuthKey(AuthKey).
event PostCompromisedNk(Nonce).
event PostCompromisedAuthProtClientExponent(Z).
event PostCompromisedAuthProtServerExponent(Z).


(******************************************************************************)
(* Макросы процессов: клиент и сервер                                        *)
(******************************************************************************)

let ClientAuth(server: Principal, allowWeakDH: bool) =
  in(io, X: Principal);
  let cUser = choosePrincipal(X, Alice, Bob) in
  new nk: Nonce;
  new b: Z;
  insert AuthProtClientEphemeralSecrets(nk, b);
  new nc: Nonce;
  event ClientStartsSession(nc);
  out(io, NC(nc));
  in(io, NS(=nc, ns, fp));
  get RSAPublicKeyTable(=server, pks, =fp) in
  event ClientGetsServerPublicKey(nc, pks);
  let encData1 = encodeRequestDHParams(D1(nc, ns, nk), pks) in
  event ClientRequestsDHParameters(nc, ns, nk);
  out(io, REQDH(nc, ns, encData1));
  in(io, DH(=nc, =ns, encAnswer: Ciphertext));
  let AN(=nc, =ns, p, g, g_a) = decodeAuthorizatioMsg(encAnswer, ns, nk) in
  event ClientReceivesDHParameters(nc, ns, nk, p, g, g_a);
  let unused = continue_if(allowWeakDH || (p <> WEAK && g <> BAD && g_a <> BAD)) in
  event ClientChecksDHParameters(nc, ns, nk, p, g, g_a, p <> WEAK && g <> BAD && g_a <> BAD);
  event ClientAcceptsDHParameters(nc, ns, nk, p, g, g_a);
  insert AuthProtClientSessionState(nc, ns, nk, p, g, g_a, b);
  let authKey = group2auth(dhExp(p, g_a, b)) in
  insert AuthKeyClientTable(cUser, server, authKey);
  let g_b = dhExp(p, g, b) in
  let encData2 = encodeAuthorizationMsg(D2(nc, ns, g_b), ns, nk) in
  event ClientEndsDHExchange(nc, ns, nk, p, g, g_a, b, authKey);
  event ClientAcceptsAuthKey(nc, ns, nk, p, g, g_a, b, authKey);
  out(io, ENDH(nc, ns, encData2));
  in(io, ACK(=nc, =ns, =hashNk(nk, authKey)));
  event ClientReceivesAck(nc, ns, nk, p, g, g_a, b, authKey);
  0.

let ServerAuth(server: Principal) =
  new sPID: ProcessID;
  get RSAServerKeyTable(=server, sks, pks) in
  get DiffieHellmanParametersTable(p,g) in
  in(io, NC(nc));
  event ServerReceivesRequest(nc);
  in(io, ns: Nonce);
  event ServerGeneratesNonce(sPID, ns);
  out(io, NS(nc, ns, fpk(pks)));
  in(io, REQDH(=nc, =ns, encData1: Ciphertext));
  let D1(=nc, =ns, nk: Nonce) = decodeRequestDHParams(encData1, sks) in
  event ServerAcceptsClient(nc, ns, nk);
  new a: Z;
  insert AuthProtServerEphemeralSecrets(a);
  let g_a = dhExp(p, g, a) in
  let encAnswer = encodeAuthorizationMsg(AN(nc, ns, p, g, g_a), ns, nk) in
  event ServerSendsDHParameters(nc, ns, nk, p, g, a);
  out(io, DH(nc, ns, encAnswer));
  in(io, ENDH(=nc, =ns, encData2: Ciphertext));
  let D2(=nc, =ns, g_b) = decodeAuthorizatioMsg(encData2, ns, nk) in
  let authKey = group2auth(dhExp(p, g_b, a)) in
  insert AuthKeyServerTable(keyID(auth2shared(authKey)), authKey);
  insert AuthProtServerSessionState(nc, ns, nk, p, g, g_b, a);
  event ServerEndsDHExchange(nc, ns, nk, p, g, g_b, a, authKey);
  event ServerAcceptsAuthKey(nc, ns, nk, p, g, g_b, a, authKey);
  event ServerSendsAck(nc, ns, nk, p, g, g_b, a, authKey);
  out(io, ACK(nc, ns, hashNk(nk, authKey)));
  0.


(******************************************************************************)
(* Вспомогательные процессы                                                   *)
(******************************************************************************)

let RegisterRSAKey(server: Principal) =
  new sk: PrivKey;
  insert RSAServerKeyTable(server, sk, pk(sk));
  insert RSAPublicKeyTable(server, pk(sk), fpk(pk(sk)));
  out(io, pk(sk));
  out(io, server);
  0.

(* Компрометация *)
let RevealRSAKey() = get RSAServerKeyTable(server, sk, _) in event RevealedRSAKey(sk); out(io, sk).
let RevealAuthKey() = get AuthKeyClientTable(_, _, k) in event RevealedAuthKey(k); out(io, k).
let RevealServerAuthKey() = get AuthKeyServerTable(_, k) in event RevealedServerAuthKey(k); out(io, k).
let RevealNk() = get AuthProtClientEphemeralSecrets(nk, _) in event RevealedNk(nk); out(io, nk).
let RevealAuthProtClientExponent() = get AuthProtClientEphemeralSecrets(_, b) in event RevealedAuthProtClientExponent(b); out(io, b).
let RevealAuthProtClientEphemeralSecrets() = get AuthProtClientEphemeralSecrets(nk, b) in event RevealedAuthProtClientEphemeralSecrets(nk, b); event RevealedNk(nk); event RevealedAuthProtClientExponent(b); out(io, (nk, b)).
let RevealAuthProtServerExponent() = get AuthProtServerEphemeralSecrets(a) in event RevealedAuthProtServerExponent(a); out(io, a).

(* Пост-компрометация *)
let PostCompromiseRSAKey() = phase 1; get RSAServerKeyTable(_, sk, _) in event PostCompromisedRSAKey(sk); out(io, sk).
let PostCompromiseAuthKey() = phase 1; get AuthKeyServerTable(_, k) in event PostCompromisedAuthKey(k); out(io, k).
let PostCompromiseNk() = phase 1; get AuthProtClientEphemeralSecrets(nk, _) in event PostCompromisedNk(nk); out(io, nk).
let PostCompromiseAuthProtClientExponent() = phase 1; get AuthProtClientEphemeralSecrets(_, b) in event PostCompromisedAuthProtClientExponent(b); out(io, b).
let PostCompromiseAuthProtServerExponent() = phase 1; get AuthProtServerEphemeralSecrets(a) in event PostCompromisedAuthProtServerExponent(a); out(io, a).

(* Генерация DH-параметров *)
let GenGoodDHParameters() = insert DiffieHellmanParametersTable(STRONG, GOOD).
let GenBadDHParameters() = new g: G; insert DiffieHellmanParametersTable(WEAK, g); insert DiffieHellmanParametersTable(STRONG, BAD); out(io, g).

(* Регистрация ключа авторизации злоумышленником *)
let RegisterAuthKey() =
  in(io, (X: Principal, k: AuthKey));
  if X <> Alice && X <> Bob then
    insert AuthKeyServerTable(keyID(auth2shared(k)), k);
    0.
