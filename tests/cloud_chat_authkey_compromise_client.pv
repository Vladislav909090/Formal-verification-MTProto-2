(*
 * MTProto 2.0: Облачные чаты
 *
 * Модель протокола обмена сообщениями между клиентом и сервером (облачные чаты)
 * с использованием долгосрочного общего ключа между клиентом и сервером Telegram.
 *)

set preciseActions = true.

(*
 * В "нормальных условиях" (без утечки долгосрочных или эфемерных секретов),
 * если честный клиент получает сообщение, зашифрованное ключом k, то его отправил сервер,
 * если только k не был раскрыт атакующему.
 *
 * Этот запрос показывает, что компрометация ключа авторизации на стороне клиента
 * позволяет атакующему выдавать себя за сервер для этого клиента.
 *)

query s, s': Nonce, m: bitstring, k: AuthKey;
  inj-event(ClientReceivesCloudMessage(s, m, k))
  ==> (inj-event(ServerSendsCloudMessage(s', m, k)) && s = s')
  || event(RevealedAuthKey(k)).
(* ✔️ Ожидаемый результат: true *)

(* Основной процесс *)

process
  let weakDiffieHellman = false in
  (0
    | !RegisterRSAKey(Server)
    | !ServerAuth(Server)
    | !ClientAuth(Server, weakDiffieHellman)
    | !ServerCloudChat()
    | !ClientCloudChat(Server)
    | !GenGoodDHParameters()
    | !RevealAuthKey()
  )