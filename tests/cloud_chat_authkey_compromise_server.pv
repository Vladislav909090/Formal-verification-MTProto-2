(*
 * MTProto 2.0: Облачные чаты
 *
 * Модель протокола обмена сообщениями между клиентом и сервером (облачные чаты)
 * с использованием долгосрочного общего ключа между клиентом и сервером Telegram.
 *)

set preciseActions = true.

(*
 * В "нормальных условиях" (без утечки долгосрочных или эфемерных секретов),
 * если честный клиент согласовал ключ k с сервером, и сервер получает сообщение,
 * зашифрованное этим ключом, то его отправил этот клиент, если только k не был раскрыт атакующему.
 *
 * Этот запрос показывает, что компрометация ключа авторизации на стороне сервера
 * позволяет атакующему выдавать себя за клиента для сервера.
 *
 * ВНИМАНИЕ: запрос не инъективен, так как в модели атакующий может воспроизводить (replay)
 * зашифрованные сообщения серверу. На практике MTProto2 защищает от replay-атак с помощью
 * временных меток и счетчиков (в модели не учитываются).
 *)
query s: Nonce, m: bitstring, k: AuthKey, nc,ns,nk: Nonce, p: Modulus, g, g_a: G, b: Z;
  event(ClientAcceptsAuthKey(nc, ns, nk, p, g, g_a, b, k))
  && event(ServerReceivesCloudMessage(s, m, k))
  ==> event(ClientSendsCloudMessage(s, m, k))
  ||  event(RevealedServerAuthKey(k)).
(* ✔️ Ожидаемый результат: true *)

(* Основной процесс *)

process
  let allowWeakDiffieHellman = false in
  (0
    | !RegisterRSAKey(Server)
    | !ServerAuth(Server)
    | !ClientAuth(Server, allowWeakDiffieHellman)
    | !ServerCloudChat()
    | !ClientCloudChat(Server)
    | !GenGoodDHParameters()
    (* Позволить атакующему узнать любой ключ авторизации *)
    | !RevealServerAuthKey()
  )